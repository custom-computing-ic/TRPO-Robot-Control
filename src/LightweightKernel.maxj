import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;


class LightweightKernel extends Kernel {

    LightweightKernel(KernelParameters parameters)
    
    {
    
    super(parameters);

    /////////////////////// Parameters ///////////////////////
    
    // Note: LayerSize here should be padded number
    int NumLayers     = Def.NumLayers;
    int  [] LayerSize = Def.LayerSize;
    int  [] NumBlocks = Def.NumBlocks;

    // Vector Types
    DFEVectorType<DFEVar> InVecType = new DFEVectorType<DFEVar>(Def.InputType, NumBlocks[0]);
    DFEVectorType<DFEVar> ObVecType = new DFEVectorType<DFEVar>(Def.DataType, NumBlocks[0]);

    DFEVectorType<DFEVar> ObservVecType = new DFEVectorType<DFEVar>(Def.DataType, Def.NumLightweightSimulators);
    DFEVectorType<DFEVar> ActionVecType = new DFEVectorType<DFEVar>(Def.DataType, Def.NumLightweightSimulators);
    DFEVectorType<DFEVector<DFEVar>> ObservGridVecType = new DFEVectorType<DFEVector<DFEVar>>(ObservVecType, Def.ObservSpaceDim);
    DFEVectorType<DFEVector<DFEVar>> ActionGridVecType = new DFEVectorType<DFEVector<DFEVar>>(ActionVecType, Def.ActionSpaceDim);
    DFEVectorType<DFEVar> RewardVecType = new DFEVectorType<DFEVar>(Def.DataType, Def.NumLightweightSimulators);

    DFEVectorType<DFEVar> FixObVecType = new DFEVectorType<DFEVar>(Def.DataType, Def.ObservSpaceDim);
    DFEVectorType<DFEVar> FixAcVecType = new DFEVectorType<DFEVar>(Def.DataType, Def.ActionSpaceDim);
    DFEVectorType<DFEVar> OutObVecType = new DFEVectorType<DFEVar>(Def.InputType, Def.ObservSpaceDim);
    DFEVectorType<DFEVar> OutAcVecType = new DFEVectorType<DFEVar>(Def.InputType, Def.ActionSpaceDim);

    // Calculate BlockDim
    int [] BlockDim = new int[NumLayers];
    for (int i=0; i<NumLayers; ++i) BlockDim[i] = LayerSize[i] / NumBlocks[i];
    
    // Number of Cycles for Weight Initialisation
    int FstLayerWeightInitCycles = BlockDim[0] * LayerSize[1];
    int SndLayerWeightInitCycles = BlockDim[1] * LayerSize[2];
    int TrdLayerWeightInitCycles = BlockDim[2] * LayerSize[3];
    int WeightInitCycles = FstLayerWeightInitCycles + SndLayerWeightInitCycles + TrdLayerWeightInitCycles;    

    // Number of Cycles for Bias & Std Initialisation
    int FstLayerBiasInitCycles = LayerSize[1];
    int SndLayerBiasInitCycles = LayerSize[2];
    int TrdLayerBiasInitCycles = LayerSize[3];
    int          StdInitCycles = LayerSize[3];
    int BiasStdInitCycles = FstLayerBiasInitCycles + SndLayerBiasInitCycles + TrdLayerBiasInitCycles + StdInitCycles;

    // Number of Cycles for Each Round of Simulation (Forward Propagation + ForwardKinematicsCalcLatency)
    int MaxBlkDim0Dim2 = Math.max(BlockDim[0], BlockDim[2]);
    int FwdPropCyclesPerSample = BlockDim[0] + (BlockDim[1]-1)*MaxBlkDim0Dim2 + BlockDim[2]*BlockDim[3];
    int SimulationCyclesPerSample = FwdPropCyclesPerSample + Def.ForwardKinematicsCalcLatency;

    // Total Simulation Time
    int NumSimulationRounds = Def.NumSamples / Def.NumLightweightSimulators;
    int NumSimulationCycles = NumSimulationRounds * SimulationCyclesPerSample;
    
   
    /////////////////////// Control - Initialisation ///////////////////////

    // Overall Control
    DFEVar Tick = control.count.simpleCounter(32);
    DFEVar beginInit       = (Tick === 1);
    DFEVar beginSimulation = (Tick === WeightInitCycles);

    // Weight Initialisation Control
    DFEVar beginWeightInit = beginInit;
    AddrGenerator WeightInitCounter = new AddrGenerator(this, 1, WeightInitCycles, beginWeightInit);
    DFEVar isWeightInitiating = WeightInitCounter.isValid();

    // Bias Initialisation Control
    DFEVar beginBiasStdInit = beginInit;
    AddrGenerator BiasStdInitCounter = new AddrGenerator(this, 1, BiasStdInitCycles, beginBiasStdInit);
    DFEVar isBiasStdInitiating = BiasStdInitCounter.isValid();


    /////////////////////// Control - Simulation ///////////////////////

    // Lightweight Simulation Control
    AddrGenerator LightweightSimulationCounter = new AddrGenerator(this, 1, NumSimulationCycles, beginSimulation);
    DFEVar isSimulating = LightweightSimulationCounter.isValid();

    // Inner Loop - Counting the Simulation of a sample
    // Note: When this counter wraps, it means the system is ready to simulate another sample
    Count.Params InnerLoopCounterParam = control.count.makeParams(16)
                                                  .withInitValue(0)
                                                  .withMax(SimulationCyclesPerSample)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(beginSimulation);
    Counter InnerLoopCounter = control.count.makeCounter(InnerLoopCounterParam);
    DFEVar InnerLoopCount = InnerLoopCounter.getCount();

    // Outer Loop - Counting the number of Simulation Rounds
    Count.Params OuterLoopCounterParam = control.count.makeParams(16)
                                                  .withInitValue(0)
                                                  .withEnable(InnerLoopCounter.getWrap())
                                                  .withWrapMode(WrapMode.STOP_AT_MAX)
                                                  .withReset(beginSimulation);
    Counter OuterLoopCounter = control.count.makeCounter(OuterLoopCounterParam);
    DFEVar OuterLoopCount = OuterLoopCounter.getCount();

    // Forward Propagation Control
    DFEVar beginFwdProp = isSimulating & (InnerLoopCount === 0);


    /////////////////////// Input ///////////////////////
    
    // Weight Input to Kernel - cast to fix point
    DFEVector<DFEVar> InVec = io.input("WeightInit", InVecType, isWeightInitiating);
    DFEVector<DFEVar> WeightInitData = InVec.cast(ObVecType);

    // Bias and Std Input to Kernel - cast to fix point
    DFEVar InBiasStd       = io.input("BiasStdInit", Def.InputType, isBiasStdInitiating);
    DFEVar BiasStdInitData = InBiasStd.cast(Def.DataType);


    /////////////////////// Lightweight Simulator ///////////////////////

    DFEVector<DFEVector<DFEVar>> ObservGridVec = ObservGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>>   MeanGridVec = ActionGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>>    StdGridVec = ActionGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>> ActionGridVec = ActionGridVecType.newInstance(this);
    DFEVector<DFEVar> RewardVec = RewardVecType.newInstance(this);
    
    @SuppressWarnings("unchecked")
    LightweightSimulator [] LW = new LightweightSimulator[Def.NumLightweightSimulators];
    for (int i=0; i<Def.NumLightweightSimulators; ++i) {
        DFEVar beginSimulation_i = stream.offset(beginSimulation, 16*i);
        LW[i] = new LightweightSimulator(this, i, WeightInitData, BiasStdInitData, beginInit, beginSimulation_i);
        DFEVector<DFEVar> Observ = LW[i].getObserv();
        DFEVector<DFEVar>   Mean = LW[i].getMean();
        DFEVector<DFEVar>    Std = LW[i].getStd();
        DFEVector<DFEVar> Action = LW[i].getAction();
        for (int dim=0; dim<Def.ObservSpaceDim; ++dim) ObservGridVec[dim][i] <== Observ[dim];
        for (int dim=0; dim<Def.ActionSpaceDim; ++dim)   MeanGridVec[dim][i] <==   Mean[dim];
        for (int dim=0; dim<Def.ActionSpaceDim; ++dim)    StdGridVec[dim][i] <==    Std[dim];
        for (int dim=0; dim<Def.ActionSpaceDim; ++dim) ActionGridVec[dim][i] <== Action[dim];
        RewardVec[i] <== LW[i].getReward();
    }


    /////////////////////// Outputs ///////////////////////

    // Observ Selection Signal
    DFEVar ObservSelection = LW[0].isObservValid();
    for (int i=1; i<Def.NumLightweightSimulators; ++i) {
        ObservSelection = LW[i].isObservValid().cat(ObservSelection);
    }
    ObservSelect = ObservSelection.cast(dfeUInt(Def.NumLightweightSimulators));

    // Mean Std Action Reward Selection Signal
    DFEVar ActionRewardSelection = LW[0].isActionRewardValid();
    for (int i=1; i<Def.NumLightweightSimulators; ++i) {
        ActionRewardSelection = LW[i].isActionRewardValid().cat(ActionRewardSelection);
    }
    ActionRewardSelect = ActionRewardSelection.cast(dfeUInt(Def.NumLightweightSimulators));

    // Observation Output
    DFEVector<DFEVar> FixObservVec = FixObVecType.newInstance(this);
    for (int dim=0; dim<Def.ObservSpaceDim; ++dim) {
        FixObservVec[dim] <== control.oneHotMux(ObservSelect, ObservGridVec[dim].getElementsAsList());
    }
    DFEVector<DFEVar> OutObservVec = FixObservVec.cast(OutObVecType);

    // Mean Std Action Output
    DFEVector<DFEVar>   FixMeanVec = FixAcVecType.newInstance(this);
    DFEVector<DFEVar>    FixStdVec = FixAcVecType.newInstance(this);
    DFEVector<DFEVar> FixActionVec = FixAcVecType.newInstance(this);
    for (int dim=0; dim<Def.ActionSpaceDim; ++dim) {
          FixMeanVec[dim] <== control.oneHotMux(ActionRewardSelect,   MeanGridVec[dim].getElementsAsList());
           FixStdVec[dim] <== control.oneHotMux(ActionRewardSelect,    StdGridVec[dim].getElementsAsList());
        FixActionVec[dim] <== control.oneHotMux(ActionRewardSelect, ActionGridVec[dim].getElementsAsList());
    }
    DFEVector<DFEVar>   OutMeanVec = FixMeanVec.cast(OutAcVecType);
    DFEVector<DFEVar>    OutStdVec = FixStdVec.cast(OutAcVecType);
    DFEVector<DFEVar> OutActionVec = FixActionVec.cast(OutAcVecType);

    // Reward Output
    DFEVar FixReward = control.oneHotMux(ActionRewardSelect, RewardVec.getElementsAsList());
    DFEVar OutReward = FixReward.cast(Def.InputType);

    // Output Control Signal
    DFEVar EnObservOutput = (ObservSelect !== 0);
    DFEVar EnActionRewardOutput = (ActionRewardSelect !== 0);



    io.output("Reward", OutReward, Def.InputType, EnActionRewardOutput);

    //debug.simPrintf(isLW1Valid, "[%4d] Mean = (%f, %f, %f), Std = (%f, %f, %f)\n", Tick, Mean[0], Mean[1], Mean[2], Std[0], Std[1], Std[2]);

    }

}
